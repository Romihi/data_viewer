<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Viewer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* Eye-friendly color palette */
        :root {
            --bg-main: #f5f3ed;
            --bg-panel: #faf9f5;
            --bg-hover: #f0ede4;
            --bg-input: #ffffff;
            --border-color: #e5e1d8;
            --text-primary: #2d2d2d;
            --text-secondary: #5a5a5a;
        }
        body {
            background-color: var(--bg-main);
            color: var(--text-primary);
        }
        .bg-panel {
            background-color: var(--bg-panel) !important;
        }
        .bg-main {
            background-color: var(--bg-main) !important;
        }
        .hover\:bg-panel-hover:hover {
            background-color: var(--bg-hover) !important;
        }
        .border-panel {
            border-color: var(--border-color) !important;
        }
        .bg-input {
            background-color: var(--bg-input) !important;
        }
        .resize-handle {
            position: absolute;
            background: #3B82F6;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 100;
            pointer-events: auto;
        }
        .resize-handle:hover, .resize-handle.active {
            opacity: 1;
            background: #2563EB;
        }
        .resize-handle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 1px;
        }
        .resize-handle-h {
            cursor: ew-resize;
            width: 6px;
            top: 0;
            bottom: 0;
            right: -3px;
            border-radius: 3px;
        }
        .resize-handle-h::before {
            width: 2px;
            height: 20px;
        }
        .resize-handle-v {
            cursor: ns-resize;
            height: 8px;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 3px;
        }
        .resize-handle-v::before {
            width: 20px;
            height: 2px;
        }
        .resizable-panel {
            position: relative;
            overflow: visible;
            padding-bottom: 8px;
            z-index: 1;
        }
        .image-grid {
            display: grid;
            gap: 0.5rem;
            height: 100%;
        }
        .compact-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            padding: 0.5rem;
        }
        .chart-container {
            cursor: crosshair;
            position: relative;
            overflow: hidden;
            min-height: 200px;
        }
        .deleted-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 0, 0, 0.1),
                rgba(255, 0, 0, 0.1) 10px,
                transparent 10px,
                transparent 20px
            );
            pointer-events: none;
            border-radius: 0.375rem;
        }
        .delete-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
        }
        .file-browser {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
        }
        .file-item {
            padding: 0.5rem;
            border-bottom: 1px solid #f3f4f6;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .file-item:hover {
            background-color: #f9fafb;
        }
        .file-item.data-folder {
            background-color: #fef3c7;
            font-weight: 600;
        }
        .file-item.data-folder:hover {
            background-color: #fcd34d;
        }
        .smoothing-tooltip-wrapper {
            position: relative;
            display: inline-block;
        }
        .smoothing-tooltip {
            visibility: hidden;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            width: 400px;
            background-color: #1f2937;
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.4;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
        }
        .smoothing-tooltip-wrapper:hover .smoothing-tooltip {
            visibility: visible;
            opacity: 1;
        }
        .smoothing-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            right: 20px;
            border: 6px solid transparent;
            border-bottom-color: #1f2937;
        }
        .smoothing-tooltip h4 {
            font-weight: 600;
            margin: 0 0 6px 0;
            font-size: 12px;
            color: #fbbf24;
        }
        .smoothing-tooltip ul {
            margin: 4px 0;
            padding-left: 16px;
        }
        .smoothing-tooltip li {
            margin: 2px 0;
        }
        .smoothing-tooltip code {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
        }
        .range-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background-color: var(--bg-hover);
            border-radius: 0.375rem;
            border: 1px solid var(--border-color);
            height: 40px;
            flex-shrink: 0;
        }
        .range-input {
            width: 80px;
            padding: 0.25rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.25rem;
            font-size: 0.75rem;
            background-color: var(--bg-input);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        {% raw %}
        const { useState, useEffect, useRef, useCallback } = React;

        const API_BASE = '';

        // File Browser component
        function FileBrowser({ onSelectFolder, onClose }) {
            const [currentPath, setCurrentPath] = useState('');
            const [items, setItems] = useState([]);
            const [loading, setLoading] = useState(false);

            const browseDirectory = async (path = '') => {
                setLoading(true);
                try {
                    const response = await fetch(`${API_BASE}/api/browse?path=${encodeURIComponent(path)}`);
                    const data = await response.json();
                    
                    if (data.error) {
                        console.error('Browse error:', data.error);
                        return;
                    }
                    
                    setCurrentPath(data.current_path);
                    setItems(data.items);
                } catch (error) {
                    console.error('Error browsing directory:', error);
                } finally {
                    setLoading(false);
                }
            };

            useEffect(() => {
                browseDirectory();
            }, []);

            const handleItemClick = (item) => {
                if (item.is_data_folder) {
                    onSelectFolder(item.path);
                } else if (item.type === 'directory' || item.type === 'parent') {
                    browseDirectory(item.path);
                }
            };

            const getFolderIcon = (item) => {
                if (item.type === 'parent') return '‚¨ÜÔ∏è';
                if (item.is_data_folder) return 'üìä';
                return 'üìÅ';
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center" style={{ zIndex: 9999 }}>
                    <div className="bg-panel rounded-lg shadow-xl w-96 max-w-full max-h-full overflow-hidden" style={{ zIndex: 10000 }}>
                        <div className="flex items-center justify-between p-4 border-b">
                            <h3 className="text-lg font-semibold">Select Data Folder</h3>
                            <button 
                                onClick={onClose}
                                className="text-gray-500 hover:text-gray-700"
                            >
                                ‚úï
                            </button>
                        </div>
                        
                        <div className="p-4">
                            <div className="text-sm text-gray-600 mb-2 truncate" title={currentPath}>
                                üìç {currentPath}
                            </div>
                            
                            {loading ? (
                                <div className="flex items-center justify-center py-8">
                                    <div className="text-gray-500">Loading...</div>
                                </div>
                            ) : (
                                <div className="file-browser">
                                    {items.map((item, index) => (
                                        <div
                                            key={index}
                                            className={`file-item ${item.is_data_folder ? 'data-folder' : ''}`}
                                            onClick={() => handleItemClick(item)}
                                        >
                                            <span>{getFolderIcon(item)}</span>
                                            <span className="flex-1 truncate">{item.name}</span>
                                            {item.is_data_folder && (
                                                <span className="text-xs text-orange-600">DATA</span>
                                            )}
                                        </div>
                                    ))}
                                    
                                    {items.length === 0 && (
                                        <div className="p-4 text-center text-gray-500">
                                            No folders found
                                        </div>
                                    )}
                                </div>
                            )}
                        </div>
                        
                        <div className="p-4 border-t text-xs text-gray-500">
                            üí° Yellow folders contain Donkey Car data
                        </div>
                    </div>
                </div>
            );
        }

        // Resizable panel component
        function ResizablePanel({ children, direction = 'horizontal', initialSize = 50, minSize = 100, maxSize = null, onResize }) {
            const [size, setSize] = useState(initialSize);
            const [isResizing, setIsResizing] = useState(false);
            const panelRef = useRef(null);

            // Update size when initialSize prop changes (for restoring saved state)
            useEffect(() => {
                if (initialSize && initialSize !== size) {
                    setSize(initialSize);
                }
            }, [initialSize]);

            const handleMouseDown = useCallback((e) => {
                setIsResizing(true);
                e.preventDefault();
            }, [direction]);

            useEffect(() => {
                const handleMouseMove = (e) => {
                    if (!isResizing || !panelRef.current) {
                        return;
                    }

                    const panel = panelRef.current;
                    const container = panel.parentElement;
                    const containerRect = container.getBoundingClientRect();

                    let newSize;
                    if (direction === 'horizontal') {
                        // Calculate new width based on mouse position relative to container start
                        newSize = e.clientX - containerRect.left;
                        // Limit to container width - allow up to 90% for better flexibility
                        const maxWidth = maxSize || containerRect.width * 0.9; // Max 90% of container
                        newSize = Math.min(newSize, maxWidth);
                        newSize = Math.max(newSize, minSize); // Ensure minimum size
                    } else {
                        // For vertical, calculate from container top
                        const panelRect = panel.getBoundingClientRect();
                        newSize = e.clientY - panelRect.top;
                        // Limit to reasonable height range
                        const maxHeight = maxSize || containerRect.height * 0.8;
                        newSize = Math.min(newSize, maxHeight);
                        newSize = Math.max(newSize, minSize);
                    }

                    setSize(newSize);
                    if (onResize) onResize(newSize);
                };

                const handleMouseUp = () => {
                    setIsResizing(false);
                };

                if (isResizing) {
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                }

                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [isResizing, direction, minSize, maxSize, onResize]);

            const style = direction === 'horizontal'
                ? { width: `${size}px`, minWidth: `${minSize}px`, flexShrink: 0 }
                : { height: `${size}px`, minHeight: `${minSize}px`, flexShrink: 0 };

            return (
                <div ref={panelRef} className="resizable-panel" style={style}>
                    {children}
                    <div 
                        className={`resize-handle resize-handle-${direction === 'horizontal' ? 'h' : 'v'} ${isResizing ? 'active' : ''}`}
                        onMouseDown={handleMouseDown}
                    />
                </div>
            );
        }

        function DonkeycarViewer() {
            const [folders, setFolders] = useState([]);
            const [selectedFolder, setSelectedFolder] = useState(null);
            const [dataInfo, setDataInfo] = useState(null);
            const [records, setRecords] = useState([]);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [statistics, setStatistics] = useState({});
            const [selectedKeys, setSelectedKeys] = useState(['user/throttle', 'user/angle']);
            const [visibleKeys, setVisibleKeys] = useState({});
            const [playing, setPlaying] = useState(false);
            const [playbackSpeed, setPlaybackSpeed] = useState(1);
            const [playDirection, setPlayDirection] = useState(1); // 1 for forward, -1 for reverse
            const [imagesPanelWidth, setImagesPanelWidth] = useState(400);
            const [timelineHeight, setTimelineHeight] = useState(400);
            const [deletedIndexes, setDeletedIndexes] = useState([]);
            const [showFileBrowser, setShowFileBrowser] = useState(false);
            const [zoomRange, setZoomRange] = useState({ min: 0, max: null });
            const [tempRange, setTempRange] = useState({ min: '', max: '' });
            const [preloadedImages, setPreloadedImages] = useState(new Map());
            const [normalizeData, setNormalizeData] = useState(false);
            const [visibleImageKeys, setVisibleImageKeys] = useState({});
            const [smoothingOption, setSmoothingOption] = useState('none');
            const [deleteStartIdx, setDeleteStartIdx] = useState('');
            const [deleteEndIdx, setDeleteEndIdx] = useState('');
            const chartRef = useRef(null);
            const chartInstance = useRef(null);
            const chartUpdatePending = useRef(false);
            const lastChartUpdate = useRef(0);
            const preloadingImages = useRef(new Set()); // Track images currently being loaded
            const preloadedImagesRef = useRef(preloadedImages); // Ref to access latest preloaded images
            const histogramInstance = useRef(null);

            // Update ref when preloadedImages changes
            useEffect(() => {
                preloadedImagesRef.current = preloadedImages;
            }, [preloadedImages]);

            // LocalStorage helpers
            const STORAGE_KEY = 'donkeycar_viewer_state';

            const saveState = (state) => {
                try {
                    const currentState = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
                    const newState = { ...currentState, ...state };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(newState));
                } catch (error) {
                    console.error('Error saving state:', error);
                }
            };

            const loadState = () => {
                try {
                    const state = localStorage.getItem(STORAGE_KEY);
                    return state ? JSON.parse(state) : {};
                } catch (error) {
                    console.error('Error loading state:', error);
                    return {};
                }
            };

            // Load folders and saved state on mount
            useEffect(() => {
                loadFolders();

                // Load saved state
                const savedState = loadState();

                // Restore panel sizes
                if (savedState.imagesPanelWidth) {
                    setImagesPanelWidth(savedState.imagesPanelWidth);
                }
                if (savedState.timelineHeight) {
                    setTimelineHeight(savedState.timelineHeight);
                }

                // Auto-load last folder if available
                if (savedState.selectedFolder) {
                    setTimeout(() => {
                        loadData(savedState.selectedFolder);
                    }, 100);
                }
            }, []);

            // Save panel sizes when they change
            useEffect(() => {
                if (imagesPanelWidth > 0) {
                    saveState({ imagesPanelWidth });
                }
            }, [imagesPanelWidth]);

            useEffect(() => {
                if (timelineHeight > 0) {
                    saveState({ timelineHeight });
                }
            }, [timelineHeight]);

            // Save selected folder when it changes
            useEffect(() => {
                if (selectedFolder) {
                    saveState({ selectedFolder });
                }
            }, [selectedFolder]);

            // Save selected data keys when they change
            useEffect(() => {
                if (selectedKeys.length > 0) {
                    saveState({ selectedDataKey: selectedKeys[0] });
                }
            }, [selectedKeys]);

            // Save visible keys (Timeline data selection) when they change
            useEffect(() => {
                if (Object.keys(visibleKeys).length > 0) {
                    saveState({ visibleKeys });
                }
            }, [visibleKeys]);

            // Save visible image keys when they change
            useEffect(() => {
                if (Object.keys(visibleImageKeys).length > 0) {
                    saveState({ visibleImageKeys });
                }
            }, [visibleImageKeys]);

            // [Removed old auto-play code - replaced with new playback control below]

            const loadFolders = async () => {
                try {
                    // Load from current directory to find data* folders
                    const response = await fetch(`${API_BASE}/api/folders?path=.`);
                    const data = await response.json();
                    setFolders(data.folders || []);
                } catch (error) {
                    console.error('Error loading folders:', error);
                }
            };

            const loadData = async (folderPath) => {
                try {
                    const response = await fetch(`${API_BASE}/api/load_data`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ folder_path: folderPath }),
                    });
                    const result = await response.json();
                    
                    if (result.success) {
                        setDataInfo(result.info);
                        setSelectedFolder(folderPath);
                        setDeletedIndexes(result.info.deleted_indexes || []);
                        
                        // Load initial records
                        await loadRecords();
                        
                        // Load statistics
                        await loadStatistics();
                        
                        // Reset zoom range
                        setZoomRange({ min: 0, max: null });
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                }
            };

            const loadRecords = async (start = 0, end = null) => {
                try {
                    let url = `${API_BASE}/api/data?start=${start}`;
                    if (end !== null) {
                        url += `&end=${end}`;
                    }
                    const response = await fetch(url);
                    const data = await response.json();
                    const records = data.records || [];
                    setRecords(records);

                    // Initialize visible image keys - restore saved state or default to all visible
                    if (records.length > 0) {
                        const firstRecord = records[0];
                        const imageKeys = Object.keys(firstRecord).filter(key => key.endsWith('/image_array'));

                        // Try to restore saved image visibility
                        const savedState = loadState();
                        const savedVisibleImageKeys = savedState.visibleImageKeys;

                        const initialImageVisible = {};
                        imageKeys.forEach(key => {
                            // If saved state exists and has this key, use saved value; otherwise default to true
                            if (savedVisibleImageKeys && key in savedVisibleImageKeys) {
                                initialImageVisible[key] = savedVisibleImageKeys[key];
                            } else {
                                initialImageVisible[key] = true;
                            }
                        });
                        setVisibleImageKeys(initialImageVisible);

                        // Set default delete range: 0 to max index
                        setDeleteStartIdx('0');
                        setDeleteEndIdx((records.length - 1).toString());
                    }
                } catch (error) {
                    console.error('Error loading records:', error);
                }
            };

            const loadStatistics = async () => {
                try {
                    const response = await fetch(`${API_BASE}/api/statistics`);
                    const stats = await response.json();
                    setStatistics(stats);

                    // Restore saved state
                    const savedState = loadState();

                    // Restore visible keys (Timeline data selection) or use defaults
                    if (savedState.visibleKeys) {
                        const restoredVisible = {};
                        Object.keys(stats).forEach(key => {
                            // If saved state has this key, use saved value; otherwise default to false
                            restoredVisible[key] = savedState.visibleKeys[key] || false;
                        });
                        setVisibleKeys(restoredVisible);
                    } else {
                        // Initialize visible keys - default to user/angle and user/throttle
                        const initialVisible = {};
                        Object.keys(stats).forEach(key => {
                            initialVisible[key] = key === 'user/angle' || key === 'user/throttle';
                        });
                        setVisibleKeys(initialVisible);
                    }

                    // Restore saved data key selection for timeline
                    if (savedState.selectedDataKey && Object.keys(stats).includes(savedState.selectedDataKey)) {
                        setSelectedKeys([savedState.selectedDataKey]);
                    }
                } catch (error) {
                    console.error('Error loading statistics:', error);
                }
            };

            // Smoothing functions
            const applySmoothing = (data, option) => {
                if (option === 'none' || data.length === 0) return data;

                // Moving Average
                if (option.startsWith('ma-')) {
                    const windowSize = parseInt(option.split('-')[1]);
                    const smoothed = [];
                    for (let i = 0; i < data.length; i++) {
                        const start = Math.max(0, i - Math.floor(windowSize / 2));
                        const end = Math.min(data.length, i + Math.ceil(windowSize / 2));
                        const window = data.slice(start, end);
                        const sum = window.reduce((acc, val) => acc + val, 0);
                        smoothed.push(sum / window.length);
                    }
                    return smoothed;
                }

                // Exponential Moving Average
                if (option.startsWith('ema-')) {
                    const alpha = parseFloat(option.split('-')[1]);
                    const smoothed = [data[0]];
                    for (let i = 1; i < data.length; i++) {
                        smoothed.push(alpha * data[i] + (1 - alpha) * smoothed[i - 1]);
                    }
                    return smoothed;
                }

                return data;
            };

            const createChart = () => {
                if (!chartRef.current || !records.length) return;

                const ctx = chartRef.current.getContext('2d');

                // Destroy existing chart
                if (chartInstance.current) {
                    chartInstance.current.destroy();
                }

                // Prepare datasets for all visible keys
                const datasets = Object.keys(visibleKeys)
                    .filter(key => visibleKeys[key])
                    .map((key, idx) => {
                        const color = `hsl(${(idx * 360) / Object.keys(visibleKeys).length}, 70%, 50%)`;

                        // Get raw data
                        const rawData = records.map(record => record[key] || 0);

                        // Normalize data if enabled
                        let processedData;
                        if (normalizeData) {
                            const min = Math.min(...rawData);
                            const max = Math.max(...rawData);
                            const range = max - min;
                            processedData = rawData.map(value => {
                                if (range === 0) return 0;
                                return 2 * (value - min) / range - 1;
                            });
                        } else {
                            processedData = rawData;
                        }

                        // Apply smoothing if enabled
                        processedData = applySmoothing(processedData, smoothingOption);

                        return {
                            label: key,
                            data: processedData.map((value, idx) => ({
                                x: idx,
                                y: value
                            })),
                            borderColor: color,
                            backgroundColor: color + '20',
                            borderWidth: 1.5,
                            pointRadius: 0,
                            tension: 0.1
                        };
                    });

                // Create new chart
                chartInstance.current = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        resizeDelay: 0,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        onClick: (event, elements, chart) => {
                            // Handle click on chart to seek
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                            const newIndex = Math.round(Math.max(0, Math.min(records.length - 1, dataX)));
                            setCurrentIndex(newIndex);
                        },
                        onZoomComplete: function({chart}) {
                            // Update zoom range when user zooms
                            const xScale = chart.scales.x;
                            setZoomRange({
                                min: Math.round(xScale.min),
                                max: Math.round(xScale.max)
                            });
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'right',
                                labels: {
                                    boxWidth: 12,
                                    padding: 10,
                                    font: {
                                        size: 11
                                    }
                                }
                            },
                            annotation: {
                                annotations: {
                                    timeline: {
                                        type: 'line',
                                        scaleID: 'x',
                                        value: currentIndex,
                                        borderColor: 'rgb(255, 99, 132)',
                                        borderWidth: 3,
                                        borderDash: [5, 5],
                                        label: {
                                            display: true,
                                            content: `Frame ${currentIndex}`,
                                            position: 'start',
                                            backgroundColor: 'rgba(255, 99, 132, 0.8)',
                                            font: {
                                                size: 10
                                            }
                                        }
                                    },
                                    // Add deleted indexes as background boxes (only within visible range for performance)
                                    ...(() => {
                                        // Create a mapping from _absolute_index to display index for efficiency
                                        const absoluteToDisplayMap = new Map();
                                        records.forEach((record, idx) => {
                                            if (record._absolute_index !== undefined) {
                                                absoluteToDisplayMap.set(record._absolute_index, idx);
                                            }
                                        });

                                        const minRange = zoomRange.min || 0;
                                        const maxRange = zoomRange.max || records.length - 1;

                                        return deletedIndexes.reduce((acc, delIndex) => {
                                            const displayIndex = absoluteToDisplayMap.get(delIndex);
                                            if (displayIndex !== undefined && displayIndex >= minRange && displayIndex <= maxRange) {
                                                acc[`deleted_${delIndex}`] = {
                                                    type: 'box',
                                                    xMin: displayIndex - 0.4,
                                                    xMax: displayIndex + 0.4,
                                                    yMin: 'min',
                                                    yMax: 'max',
                                                    backgroundColor: 'rgba(255, 0, 0, 0.1)',
                                                    borderColor: 'rgba(255, 0, 0, 0.3)',
                                                    borderWidth: 1,
                                                    borderDash: [5, 5]
                                                };
                                            }
                                            return acc;
                                        }, {});
                                    })()
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        return `Index: ${Math.round(context[0].parsed.x)}`;
                                    }
                                }
                            },
                            zoom: {
                                pan: {
                                    enabled: true,
                                    mode: 'x',
                                    onPanComplete: function({chart}) {
                                        // Update range when user pans
                                        const xScale = chart.scales.x;
                                        setZoomRange({
                                            min: Math.round(xScale.min),
                                            max: Math.round(xScale.max)
                                        });
                                    }
                                },
                                zoom: {
                                    wheel: {
                                        enabled: true,
                                    },
                                    pinch: {
                                        enabled: true
                                    },
                                    mode: 'x',
                                    onZoomComplete: function({chart}) {
                                        // Update range when user zooms
                                        const xScale = chart.scales.x;
                                        setZoomRange({
                                            min: Math.round(xScale.min),
                                            max: Math.round(xScale.max)
                                        });
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'linear',
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Record Index'
                                },
                                min: zoomRange.min,
                                max: zoomRange.max !== null ? zoomRange.max : undefined
                            },
                            y: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'Value'
                                }
                            }
                        }
                    }
                });
            };

            const updateTimelineMarker = () => {
                if (!chartInstance.current) return;

                // Throttle chart updates for better performance at high speeds
                const now = Date.now();
                const timeSinceLastUpdate = now - lastChartUpdate.current;
                const minUpdateInterval = playbackSpeed >= 10 ? 100 : playbackSpeed >= 5 ? 50 : 16; // 100ms for 10x+, 50ms for 5x+, 16ms (~60fps) otherwise

                if (timeSinceLastUpdate < minUpdateInterval && chartUpdatePending.current) {
                    return; // Skip this update
                }

                if (chartUpdatePending.current) {
                    return; // Already have an update pending
                }

                chartUpdatePending.current = true;
                requestAnimationFrame(() => {
                    if (chartInstance.current) {
                        chartInstance.current.options.plugins.annotation.annotations.timeline.value = currentIndex;
                        chartInstance.current.options.plugins.annotation.annotations.timeline.label.content = `Frame ${currentIndex}`;
                        chartInstance.current.update('none'); // 'none' prevents animations
                        lastChartUpdate.current = Date.now();
                    }
                    chartUpdatePending.current = false;
                });
            };

            // Create combined histogram for user/angle and user/throttle
            const createHistograms = () => {
                if (records.length === 0) return;

                const angleData = records.map(r => r['user/angle']).filter(v => v !== undefined && v !== null);
                const throttleData = records.map(r => r['user/throttle']).filter(v => v !== undefined && v !== null);

                // Fixed range from -1 to 1
                const min = -1;
                const max = 1;
                const bins = 20;
                const binWidth = (max - min) / bins;

                // Create all bin labels from -1 to 1
                const labels = [];
                for (let i = 0; i < bins; i++) {
                    const binStart = min + i * binWidth;
                    labels.push(binStart.toFixed(2));
                }

                const createHistogramData = (data) => {
                    const counts = new Array(bins).fill(0);

                    data.forEach(value => {
                        // Only count values within -1 to 1 range
                        if (value >= min && value <= max) {
                            // Find which bin this value belongs to
                            const binIndex = Math.floor((value - min) / binWidth);
                            // Handle edge case where value === max
                            const safeBinIndex = Math.min(binIndex, bins - 1);
                            counts[safeBinIndex]++;
                        }
                    });

                    return counts;
                };

                // Create histogram data for both
                const angleCounts = createHistogramData(angleData);
                const throttleCounts = createHistogramData(throttleData);

                // Create combined histogram
                const canvas = document.getElementById('histogram');
                if (canvas) {
                    if (histogramInstance.current) {
                        histogramInstance.current.destroy();
                    }
                    histogramInstance.current = new Chart(canvas, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [
                                {
                                    label: 'user/angle',
                                    data: angleCounts,
                                    backgroundColor: 'rgba(59, 130, 246, 0.5)',
                                    borderColor: 'rgba(59, 130, 246, 1)',
                                    borderWidth: 1
                                },
                                {
                                    label: 'user/throttle',
                                    data: throttleCounts,
                                    backgroundColor: 'rgba(16, 185, 129, 0.5)',
                                    borderColor: 'rgba(16, 185, 129, 1)',
                                    borderWidth: 1
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: { font: { size: 10 } }
                                },
                                tooltip: {
                                    callbacks: {
                                        title: function(context) {
                                            const binStart = parseFloat(context[0].label);
                                            const binEnd = binStart + binWidth;
                                            return `Range: ${binStart.toFixed(2)} to ${binEnd.toFixed(2)}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: { display: true, text: 'Value (-1 to 1)', font: { size: 10 } },
                                    ticks: {
                                        autoSkip: true,
                                        maxTicksLimit: 11,
                                        font: { size: 9 }
                                    }
                                },
                                y: {
                                    title: { display: true, text: 'Count', font: { size: 10 } },
                                    ticks: { font: { size: 9 } },
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                }
            };

            // Create chart when data or visible keys change
            useEffect(() => {
                createChart();
            }, [records, visibleKeys, deletedIndexes, zoomRange, normalizeData, smoothingOption]);

            // Create histograms when records change
            useEffect(() => {
                createHistograms();
            }, [records]);

            // Update only timeline marker when index changes
            useEffect(() => {
                updateTimelineMarker();
            }, [currentIndex]);

            // Playback control - only advance when images are preloaded
            useEffect(() => {
                let interval;
                if (playing && records.length > 0) {
                    // Calculate interval based on speed
                    // Target ~30fps for normal playback
                    const baseInterval = playbackSpeed === 0.5 ? 66 :  // 0.5x: 15fps (slow motion)
                                       playbackSpeed < 1 ? 1000 / (playbackSpeed * 30) :  // Other slow speeds
                                       playbackSpeed === 1 ? 33 :  // Normal speed: ~30fps
                                       playbackSpeed <= 2 ? 33 :   // 2x: 30fps (will skip frames)
                                       playbackSpeed <= 5 ? 50 :   // 5x: 20fps
                                       playbackSpeed <= 10 ? 60 : 80;  // 10x+: 16-12fps

                    interval = setInterval(() => {
                        setCurrentIndex(prev => {
                            const skipAmount = Math.max(1, Math.floor(Number(playbackSpeed)));
                            const next = prev + (skipAmount * playDirection);

                            // Check bounds
                            if (playDirection > 0 && next >= records.length) {
                                setPlaying(false);
                                return records.length - 1;
                            }
                            if (playDirection < 0 && next < 0) {
                                setPlaying(false);
                                return 0;
                            }

                            // Check if next frame's images are preloaded
                            if (next >= 0 && next < records.length) {
                                const nextRecord = records[next];
                                const imageKeys = Object.keys(nextRecord).filter(key => key.endsWith('/image_array'));

                                // Check if all images for next frame are preloaded
                                const allImagesLoaded = imageKeys.every(key => {
                                    const imageUrl = `${API_BASE}/api/image/${nextRecord[key]}`;
                                    return preloadedImagesRef.current.has(imageUrl);
                                });

                                if (!allImagesLoaded) {
                                    // Images not ready, stay at current frame
                                    return prev;
                                }
                            }

                            return next;
                        });
                    }, baseInterval);
                }
                return () => clearInterval(interval);
            }, [playing, playbackSpeed, playDirection, records.length, records]);

            // Preload images aggressively for smooth playback
            useEffect(() => {
                if (records.length === 0) {
                    return;
                }

                // When not playing, only preload current frame
                if (!playing) {
                    const record = records[currentIndex];
                    if (record) {
                        const imageKeys = Object.keys(record).filter(key => key.endsWith('/image_array'));
                        imageKeys.forEach(key => {
                            const imageUrl = `${API_BASE}/api/image/${record[key]}`;
                            if (!preloadedImages.has(imageUrl) && !preloadingImages.current.has(imageUrl)) {
                                preloadingImages.current.add(imageUrl);
                                const img = new Image();
                                img.onload = () => {
                                    setPreloadedImages(prev => {
                                        const newMap = new Map(prev);
                                        newMap.set(imageUrl, img);
                                        return newMap;
                                    });
                                    preloadingImages.current.delete(imageUrl);
                                };
                                img.onerror = () => {
                                    preloadingImages.current.delete(imageUrl);
                                };
                                img.src = imageUrl;
                            }
                        });
                    }
                    return;
                }

                const skipAmount = Math.max(1, Math.floor(Number(playbackSpeed)));
                // Preload many frames ahead to ensure images are ready
                // For 1-4x speeds, preload fewer frames since we're not skipping
                const preloadCount = playbackSpeed >= 20 ? 60 :
                                   playbackSpeed >= 10 ? 50 :
                                   playbackSpeed >= 5 ? 40 :
                                   playbackSpeed >= 2 ? 20 : 10;  // 1-2x: preload 10-20 frames ahead

                // Debug log to verify correct skipping (only for high speeds)
                if (playbackSpeed >= 10) {
                    console.log(`[Preload] Speed: ${playbackSpeed}x, Skip: ${skipAmount}, Current: ${currentIndex}`);
                }

                // Limit concurrent image loading to avoid overwhelming the browser
                // Higher limit for better performance
                const maxConcurrentLoads = 50;
                let loadCount = 0;
                const preloadIndexes = [];

                // Preload current and future frames
                for (let i = 0; i <= preloadCount && loadCount < maxConcurrentLoads; i++) {
                    const nextIndex = currentIndex + (i * skipAmount * playDirection);
                    preloadIndexes.push(nextIndex);
                    if (nextIndex >= 0 && nextIndex < records.length) {
                        const record = records[nextIndex];
                        const imageKeys = Object.keys(record).filter(key => key.endsWith('/image_array'));

                        imageKeys.forEach(key => {
                            if (loadCount >= maxConcurrentLoads) return;

                            const imageUrl = `${API_BASE}/api/image/${record[key]}`;
                            // Check if already loaded or currently loading
                            if (!preloadedImages.has(imageUrl) && !preloadingImages.current.has(imageUrl)) {
                                preloadingImages.current.add(imageUrl);
                                loadCount++;

                                const img = new Image();
                                img.onload = () => {
                                    setPreloadedImages(prev => {
                                        const newMap = new Map(prev);
                                        newMap.set(imageUrl, img);
                                        return newMap;
                                    });
                                    preloadingImages.current.delete(imageUrl);
                                };
                                img.onerror = () => {
                                    preloadingImages.current.delete(imageUrl);
                                };
                                img.src = imageUrl; // Set src after defining handlers
                            }
                        });
                    }
                }

                // Debug log to show which indexes are being preloaded (only for high speeds)
                if (playbackSpeed >= 10) {
                    const validIndexes = preloadIndexes.filter(idx => idx >= 0 && idx < records.length);
                    console.log(`[Preload] Indexes: [${validIndexes.slice(0, 10).join(', ')}${validIndexes.length > 10 ? '...' : ''}] (${validIndexes.length} total)`);
                }
            }, [currentIndex, playing, playbackSpeed, playDirection, records]);

            const toggleKeyVisibility = (key) => {
                setVisibleKeys(prev => ({
                    ...prev,
                    [key]: !prev[key]
                }));
            };

            const showAllKeys = () => {
                const newVisible = {};
                Object.keys(statistics).forEach(key => {
                    newVisible[key] = true;
                });
                setVisibleKeys(newVisible);
            };

            const hideAllKeys = () => {
                const newVisible = {};
                Object.keys(statistics).forEach(key => {
                    newVisible[key] = false;
                });
                setVisibleKeys(newVisible);
            };

            const toggleImageKeyVisibility = (key) => {
                setVisibleImageKeys(prev => ({
                    ...prev,
                    [key]: !prev[key]
                }));
            };

            const showAllImageKeys = () => {
                const newVisible = {};
                Object.keys(visibleImageKeys).forEach(key => {
                    newVisible[key] = true;
                });
                setVisibleImageKeys(newVisible);
            };

            const hideAllImageKeys = () => {
                const newVisible = {};
                Object.keys(visibleImageKeys).forEach(key => {
                    newVisible[key] = false;
                });
                setVisibleImageKeys(newVisible);
            };

            // Navigation functions
            const stepForward = () => {
                setCurrentIndex(prev => Math.min(prev + Math.max(1, Math.floor(playbackSpeed)), records.length - 1));
            };

            const stepBackward = () => {
                setCurrentIndex(prev => Math.max(prev - Math.max(1, Math.floor(playbackSpeed)), 0));
            };

            const togglePlayDirection = () => {
                setPlayDirection(prev => prev * -1);
            };

            const playForward = () => {
                setPlayDirection(1);
                setPlaying(!playing);
            };

            const playReverse = () => {
                setPlayDirection(-1);
                setPlaying(!playing);
            };

            const setDeleteIndexRange = async () => {
                const start = parseInt(deleteStartIdx);
                const end = parseInt(deleteEndIdx);

                if (isNaN(start) || isNaN(end)) {
                    alert('ÈñãÂßã„Å®ÁµÇ‰∫Ü„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                    return;
                }

                if (start > end) {
                    alert('ÈñãÂßã„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅØÁµÇ‰∫Ü„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ‰ª•‰∏ã„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô');
                    return;
                }

                if (start < 0 || end >= records.length) {
                    alert(`„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅØ0„Äú${records.length - 1}„ÅÆÁØÑÂõ≤„ÅßÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ`);
                    return;
                }

                // Convert currentIndex to _absolute_index
                const startAbsoluteIdx = records[start]?._absolute_index;
                const endAbsoluteIdx = records[end]?._absolute_index;

                if (startAbsoluteIdx === undefined || endAbsoluteIdx === undefined) {
                    alert('ÊåáÂÆö„Åï„Çå„Åü„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ„É¨„Ç≥„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                    return;
                }

                try {
                    const response = await fetch(`${API_BASE}/api/delete_indexes`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            start_idx: startAbsoluteIdx,
                            end_idx: endAbsoluteIdx
                        })
                    });

                    const result = await response.json();

                    if (response.ok) {
                        alert(`ÂâäÈô§„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíË®≠ÂÆö„Åó„Åæ„Åó„Åü (${start}„Äú${end})\nÂêàË®à: ${result.count}‰ª∂`);
                        // Reload data to reflect changes (default range will be set in loadRecords)
                        await loadData(selectedFolder);
                    } else {
                        alert(`„Ç®„É©„Éº: ${result.error}`);
                    }
                } catch (error) {
                    alert(`„Ç®„É©„Éº: ${error.message}`);
                }
            };

            const clearDeleteIndexRange = async () => {
                const start = parseInt(deleteStartIdx);
                const end = parseInt(deleteEndIdx);

                if (isNaN(start) || isNaN(end)) {
                    alert('ÈñãÂßã„Å®ÁµÇ‰∫Ü„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                    return;
                }

                if (start > end) {
                    alert('ÈñãÂßã„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅØÁµÇ‰∫Ü„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ‰ª•‰∏ã„Åß„ÅÇ„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô');
                    return;
                }

                if (start < 0 || end >= records.length) {
                    alert(`„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅØ0„Äú${records.length - 1}„ÅÆÁØÑÂõ≤„ÅßÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ`);
                    return;
                }

                // Convert currentIndex to _absolute_index
                const startAbsoluteIdx = records[start]?._absolute_index;
                const endAbsoluteIdx = records[end]?._absolute_index;

                if (startAbsoluteIdx === undefined || endAbsoluteIdx === undefined) {
                    alert('ÊåáÂÆö„Åï„Çå„Åü„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ„É¨„Ç≥„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                    return;
                }

                try {
                    const response = await fetch(`${API_BASE}/api/clear_delete_indexes`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            start_idx: startAbsoluteIdx,
                            end_idx: endAbsoluteIdx
                        })
                    });

                    const result = await response.json();

                    if (response.ok) {
                        alert(`ÂâäÈô§„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åó„Åü (${start}„Äú${end})\nÊÆã„Çä: ${result.count}‰ª∂`);
                        // Reload data to reflect changes (default range will be set in loadRecords)
                        await loadData(selectedFolder);
                    } else {
                        alert(`„Ç®„É©„Éº: ${result.error}`);
                    }
                } catch (error) {
                    alert(`„Ç®„É©„Éº: ${error.message}`);
                }
            };

            const resetZoom = () => {
                // Reset the range state first
                setZoomRange({ min: 0, max: null });
                
                // Force chart recreation by triggering useEffect
                // This ensures the chart is redrawn with the full range
                setTimeout(() => {
                    if (chartInstance.current) {
                        chartInstance.current.resetZoom();
                        
                        // Manually reset the scale options
                        const chart = chartInstance.current;
                        chart.options.scales.x.min = undefined;
                        chart.options.scales.x.max = undefined;
                        
                        // Update the chart
                        chart.update('active');
                    }
                }, 10);
            };

            const applyRange = () => {
                const min = parseInt(tempRange.min) || 0;
                const max = parseInt(tempRange.max) || records.length - 1;
                
                if (min >= 0 && max >= min && max < records.length) {
                    setZoomRange({ min, max });
                    setTempRange({ min: '', max: '' });
                    
                    // Force chart update
                    setTimeout(() => {
                        if (chartInstance.current) {
                            chartInstance.current.options.scales.x.min = min;
                            chartInstance.current.options.scales.x.max = max;
                            chartInstance.current.update('none'); // 'none' prevents animations
                        }
                    }, 10);
                } else {
                    alert('Invalid range. Please check your input values.');
                }
            };

            const setPresetRange = (percentage) => {
                const total = records.length;
                const rangeSize = Math.floor(total * percentage);
                const start = Math.max(0, currentIndex - Math.floor(rangeSize / 2));
                const end = Math.min(total - 1, start + rangeSize);
                
                setZoomRange({ min: start, max: end });
                
                // Force chart update
                setTimeout(() => {
                    if (chartInstance.current) {
                        chartInstance.current.options.scales.x.min = start;
                        chartInstance.current.options.scales.x.max = end;
                        chartInstance.current.update('none'); // 'none' prevents animations
                    }
                }, 10);
            };

            const currentRecord = records[currentIndex] || {};
            const allImageKeys = Object.keys(currentRecord).filter(key => key.endsWith('/image_array'));
            const imageKeys = allImageKeys.filter(key => visibleImageKeys[key]);

            // Dynamic grid style based on visible images
            const gridStyle = {
                gridTemplateColumns: imageKeys.length > 2 ? 'repeat(2, 1fr)' : '1fr',
                gridTemplateRows: imageKeys.length > 2 ? 'repeat(2, 1fr)' : 'auto'
            };

            return (
                <div className="min-h-screen bg-main">
                    <div className="p-2">
                        {/* Folder Selection */}
                        {!selectedFolder && (
                            <div className="bg-panel rounded-lg shadow p-6 mb-6">
                                <h2 className="text-xl font-semibold mb-4">Select Data Folder</h2>
                                <div className="mb-4">
                                    <button
                                        onClick={() => setShowFileBrowser(true)}
                                        className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition"
                                    >
                                        üìÅ Browse Folders
                                    </button>
                                </div>
                                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                                    {folders.map(folder => (
                                        <button
                                            key={folder.path}
                                            onClick={() => loadData(folder.path)}
                                            className="p-4 border rounded-lg hover:bg-blue-50 transition"
                                        >
                                            {folder.name}
                                        </button>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Data Viewer */}
                        {selectedFolder && dataInfo && (
                            <div className="flex flex-col h-screen">
                                {/* Compact header with info and controls */}
                                <div className="bg-panel rounded-lg shadow p-3 mb-2">
                                    <div className="flex items-center justify-between">
                                        {/* Data Info */}
                                        <div className="flex gap-4 text-sm items-center">
                                            <button
                                                onClick={() => setShowFileBrowser(true)}
                                                className="px-2 py-1 bg-gray-500 text-white rounded text-xs hover:bg-gray-600 transition"
                                                title="Change folder"
                                            >
                                                üìÅ
                                            </button>
                                            <span><strong>Records:</strong> {dataInfo.total_records}</span>
                                            <span><strong>Deleted:</strong> {dataInfo.deleted_indexes?.length || 0}</span>
                                            <span><strong>Sessions:</strong> {dataInfo.sessions.length}</span>
                                            <span><strong>Duration:</strong> {dataInfo.timestamp_range ? 
                                                `${(dataInfo.timestamp_range.duration_ms / 1000).toFixed(1)}s` : 'N/A'}</span>
                                        </div>

                                        {/* Playback Controls */}
                                        <div className="compact-controls">
                                            <button
                                                onClick={stepBackward}
                                                className="px-3 py-1.5 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 font-bold"
                                                title="Step Backward"
                                            >
                                                ‚èÆ
                                            </button>
                                            <button
                                                onClick={playReverse}
                                                className={`px-3 py-1.5 rounded text-sm font-bold ${playing && playDirection < 0 ? 'bg-red-500 text-white' : 'bg-blue-500 text-white hover:bg-blue-600'}`}
                                                title="Play Reverse"
                                            >
                                                ‚è™
                                            </button>
                                            <button
                                                onClick={playForward}
                                                className={`px-3 py-1.5 rounded text-sm font-bold ${playing && playDirection > 0 ? 'bg-red-500 text-white' : 'bg-blue-500 text-white hover:bg-blue-600'}`}
                                                title="Play Forward"
                                            >
                                                ‚è©
                                            </button>
                                            <button
                                                onClick={stepForward}
                                                className="px-3 py-1.5 bg-gray-500 text-white rounded text-sm hover:bg-gray-600 font-bold"
                                                title="Step Forward"
                                            >
                                                ‚è≠
                                            </button>
                                            <select
                                                value={playbackSpeed}
                                                onChange={(e) => setPlaybackSpeed(parseFloat(e.target.value))}
                                                className="px-2 py-1 border rounded text-sm"
                                            >
                                                <option value="0.5">0.5x</option>
                                                <option value="1">1x</option>
                                                <option value="2">2x</option>
                                                <option value="5">5x</option>
                                                <option value="10">10x</option>
                                                <option value="20">20x</option>
                                            </select>
                                            <input
                                                type="range"
                                                min="0"
                                                max={records.length - 1}
                                                value={currentIndex}
                                                onChange={(e) => setCurrentIndex(parseInt(e.target.value))}
                                                className="w-64"
                                            />
                                            <span className="text-sm">{currentIndex} / {records.length - 1}</span>
                                            {playing && (
                                                <span className="text-xs text-blue-600 font-bold">
                                                    {playDirection > 0 ? '‚ñ∂‚ñ∂' : '‚óÄ‚óÄ'} {playbackSpeed}x
                                                </span>
                                            )}
                                            <div className="border-l pl-2 ml-2 flex items-center gap-2">
                                                <span className="text-xs font-medium">ÂâäÈô§ÁØÑÂõ≤:</span>
                                                <div className="flex flex-col gap-1">
                                                    <input
                                                        type="number"
                                                        placeholder="ÈñãÂßã"
                                                        value={deleteStartIdx}
                                                        onChange={(e) => setDeleteStartIdx(e.target.value)}
                                                        className="w-20 px-2 py-1 border border-panel rounded text-xs bg-input"
                                                        min="0"
                                                        max={records.length - 1}
                                                    />
                                                    <button
                                                        onClick={() => setDeleteStartIdx(currentIndex.toString())}
                                                        className="px-3 py-1 bg-gray-300 text-gray-900 rounded text-xs hover:bg-gray-400"
                                                        title="ÁèæÂú®„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÈñãÂßã„Å´Ë®≠ÂÆö"
                                                    >
                                                        ÁèæÂú®
                                                    </button>
                                                </div>
                                                <span className="text-xs">„Äú</span>
                                                <div className="flex flex-col gap-1">
                                                    <input
                                                        type="number"
                                                        placeholder="ÁµÇ‰∫Ü"
                                                        value={deleteEndIdx}
                                                        onChange={(e) => setDeleteEndIdx(e.target.value)}
                                                        className="w-20 px-2 py-1 border border-panel rounded text-xs bg-input"
                                                        min="0"
                                                        max={records.length - 1}
                                                    />
                                                    <button
                                                        onClick={() => setDeleteEndIdx(currentIndex.toString())}
                                                        className="px-3 py-1 bg-gray-300 text-gray-900 rounded text-xs hover:bg-gray-400"
                                                        title="ÁèæÂú®„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÁµÇ‰∫Ü„Å´Ë®≠ÂÆö"
                                                    >
                                                        ÁèæÂú®
                                                    </button>
                                                </div>
                                                <div className="flex flex-col gap-1">
                                                    <button
                                                        onClick={setDeleteIndexRange}
                                                        className="px-3 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600"
                                                        title="ÊåáÂÆö„Åó„ÅüÁØÑÂõ≤„ÇíÂâäÈô§„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å®„Åó„Å¶Ë®≠ÂÆö"
                                                    >
                                                        ÂâäÈô§Ë®≠ÂÆö
                                                    </button>
                                                    <button
                                                        onClick={clearDeleteIndexRange}
                                                        className="px-3 py-1 bg-blue-500 text-white rounded text-xs hover:bg-blue-600"
                                                        title="ÊåáÂÆö„Åó„ÅüÁØÑÂõ≤„ÅÆÂâäÈô§„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí„ÇØ„É™„Ç¢"
                                                    >
                                                        ÂâäÈô§„ÇØ„É™„Ç¢
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Main Content */}
                                <div className="flex flex-1 gap-2" style={{ minHeight: 0 }}>
                                    {/* Images Panel */}
                                    <ResizablePanel
                                        direction="horizontal"
                                        initialSize={imagesPanelWidth}
                                        minSize={200}
                                        maxSize={800}
                                        onResize={setImagesPanelWidth}
                                    >
                                        <div className="bg-panel rounded-lg shadow p-3 h-full flex flex-col">
                                            <div className="flex justify-between items-center mb-2">
                                                <h3 className="text-sm font-semibold">Images</h3>
                                                <details className="relative" style={{ zIndex: 200 }}>
                                                    <summary className="cursor-pointer text-sm text-blue-600 hover:text-blue-800">
                                                        Select Images ({imageKeys.length}/{allImageKeys.length})
                                                    </summary>
                                                    <div className="absolute right-0 mt-1 w-48 bg-panel border-panel rounded-lg shadow-lg p-2 z-[200] max-h-64 overflow-y-auto" style={{ pointerEvents: 'auto' }}>
                                                        {/* Control buttons */}
                                                        <div className="flex gap-2 mb-2 pb-2 border-b">
                                                            <button
                                                                onClick={showAllImageKeys}
                                                                className="px-2 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600"
                                                            >
                                                                ÂÖ®„Å¶Ë°®Á§∫
                                                            </button>
                                                            <button
                                                                onClick={hideAllImageKeys}
                                                                className="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600"
                                                            >
                                                                ÂÖ®„Å¶ÈùûË°®Á§∫
                                                            </button>
                                                        </div>
                                                        {allImageKeys.map(key => (
                                                            <label key={key} className="flex items-center p-1 hover:bg-panel-hover cursor-pointer">
                                                                <input
                                                                    type="checkbox"
                                                                    checked={visibleImageKeys[key] || false}
                                                                    onChange={() => toggleImageKeyVisibility(key)}
                                                                    className="mr-2"
                                                                />
                                                                <span className="text-sm">{key}</span>
                                                            </label>
                                                        ))}
                                                    </div>
                                                </details>
                                            </div>
                                            <div
                                                className="image-grid flex-1"
                                                style={gridStyle}
                                            >
                                                {imageKeys.map(key => {
                                                    const imageUrl = `${API_BASE}/api/image/${currentRecord[key]}`;
                                                    const preloadedImg = preloadedImages.get(imageUrl);
                                                    // Only strictly require preloaded images during very high-speed playback
                                                    const requirePreload = playing && playbackSpeed >= 10;

                                                    return (
                                                    <div key={key} className="flex flex-col relative" style={{ minHeight: 0 }}>
                                                        <p className="text-xs text-gray-600 mb-1">{key}</p>
                                                        <div className="relative flex-1" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', background: '#f3f4f6', minHeight: '200px' }}>
                                                            {preloadedImg || !requirePreload ? (
                                                                <img
                                                                    src={preloadedImg ? preloadedImg.src : imageUrl}
                                                                    alt={key}
                                                                    className="w-full h-full object-contain rounded"
                                                                    style={{ maxWidth: '100%', maxHeight: '100%' }}
                                                                />
                                                            ) : (
                                                                <div className="text-xs text-gray-400">Loading...</div>
                                                            )}
                                                            {currentRecord._is_deleted && (
                                                                <>
                                                                    <div className="deleted-overlay"></div>
                                                                    <div className="delete-label">DELETE</div>
                                                                </>
                                                            )}
                                                        </div>
                                                    </div>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    </ResizablePanel>

                                    {/* Data Panel */}
                                    <div className="flex-1 flex flex-col gap-2" style={{ minWidth: '300px' }}>
                                        {/* Timeline Chart */}
                                        <ResizablePanel
                                            direction="vertical"
                                            initialSize={timelineHeight}
                                            minSize={250}
                                            onResize={setTimelineHeight}
                                        >
                                            <div className="bg-panel rounded-lg shadow p-3" style={{ height: 'calc(100% - 8px)' }}>
                                            <div className="flex justify-between items-center mb-2">
                                                <h3 className="text-sm font-semibold">Timeline</h3>
                                                <details className="relative" style={{ zIndex: 200 }}>
                                                    <summary className="cursor-pointer text-sm text-blue-600 hover:text-blue-800">
                                                        Select Data ({Object.values(visibleKeys).filter(v => v).length} active)
                                                    </summary>
                                                    <div className="absolute right-0 mt-1 w-64 bg-panel border-panel rounded-lg shadow-lg p-2 z-[200] max-h-[calc(100vh-100px)] overflow-y-auto" style={{ pointerEvents: 'auto' }}>
                                                        {/* Control buttons */}
                                                        <div className="flex gap-2 mb-2 pb-2 border-b">
                                                            <button
                                                                onClick={showAllKeys}
                                                                className="px-2 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600"
                                                            >
                                                                ÂÖ®„Å¶Ë°®Á§∫
                                                            </button>
                                                            <button
                                                                onClick={hideAllKeys}
                                                                className="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600"
                                                            >
                                                                ÂÖ®„Å¶ÈùûË°®Á§∫
                                                            </button>
                                                        </div>
                                                        {Object.keys(statistics).map(key => (
                                                            <label key={key} className="flex items-center p-1 hover:bg-panel-hover cursor-pointer">
                                                                <input
                                                                    type="checkbox"
                                                                    checked={visibleKeys[key] || false}
                                                                    onChange={() => toggleKeyVisibility(key)}
                                                                    className="mr-2"
                                                                />
                                                                <span className="text-sm">{key}</span>
                                                            </label>
                                                        ))}
                                                    </div>
                                                </details>
                                            </div>
                                            
                                            {/* Range Controls */}
                                            <div className="range-controls">
                                                <span className="text-xs font-medium">Range:</span>
                                                <input
                                                    type="number"
                                                    placeholder="Min"
                                                    value={tempRange.min}
                                                    onChange={(e) => setTempRange(prev => ({ ...prev, min: e.target.value }))}
                                                    className="range-input"
                                                    min="0"
                                                    max={records.length - 1}
                                                />
                                                <span className="text-xs">to</span>
                                                <input
                                                    type="number"
                                                    placeholder="Max"
                                                    value={tempRange.max}
                                                    onChange={(e) => setTempRange(prev => ({ ...prev, max: e.target.value }))}
                                                    className="range-input"
                                                    min="0"
                                                    max={records.length - 1}
                                                />
                                                <button
                                                    onClick={applyRange}
                                                    className="px-2 py-1 bg-blue-500 text-white rounded text-xs hover:bg-blue-600"
                                                >
                                                    Apply
                                                </button>
                                                <button
                                                    onClick={() => setPresetRange(0.1)}
                                                    className="px-2 py-1 bg-gray-500 text-white rounded text-xs hover:bg-gray-600"
                                                    title="Show 10% around current position"
                                                >
                                                    10%
                                                </button>
                                                <button
                                                    onClick={() => setPresetRange(0.25)}
                                                    className="px-2 py-1 bg-gray-500 text-white rounded text-xs hover:bg-gray-600"
                                                    title="Show 25% around current position"
                                                >
                                                    25%
                                                </button>
                                                <button
                                                    onClick={resetZoom}
                                                    className="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600"
                                                >
                                                    Reset
                                                </button>
                                                <button
                                                    onClick={() => setNormalizeData(!normalizeData)}
                                                    className={`px-2 py-1 rounded text-xs font-medium ${normalizeData ? 'bg-green-500 text-white hover:bg-green-600' : 'bg-gray-300 text-gray-700 hover:bg-gray-400'}`}
                                                    title="Normalize data to -1~1 range"
                                                >
                                                    Ê≠£Ë¶èÂåñ {normalizeData ? 'ON' : 'OFF'}
                                                </button>
                                                <div className="smoothing-tooltip-wrapper">
                                                    <select
                                                        value={smoothingOption}
                                                        onChange={(e) => setSmoothingOption(e.target.value)}
                                                        className="px-2 py-1 border rounded text-xs"
                                                    >
                                                        <option value="none">Âπ≥ÊªëÂåñ„Å™„Åó</option>
                                                        <optgroup label="ÁßªÂãïÂπ≥Âùá">
                                                            <option value="ma-3">ÁßªÂãïÂπ≥Âùá (Á™ì=3)</option>
                                                            <option value="ma-5">ÁßªÂãïÂπ≥Âùá (Á™ì=5)</option>
                                                            <option value="ma-10">ÁßªÂãïÂπ≥Âùá (Á™ì=10)</option>
                                                            <option value="ma-20">ÁßªÂãïÂπ≥Âùá (Á™ì=20)</option>
                                                        </optgroup>
                                                        <optgroup label="ÊåáÊï∞ÁßªÂãïÂπ≥Âùá">
                                                            <option value="ema-0.1">ÊåáÊï∞Âπ≥ÊªëÂåñ (Œ±=0.1)</option>
                                                            <option value="ema-0.3">ÊåáÊï∞Âπ≥ÊªëÂåñ (Œ±=0.3)</option>
                                                            <option value="ema-0.5">ÊåáÊï∞Âπ≥ÊªëÂåñ (Œ±=0.5)</option>
                                                        </optgroup>
                                                    </select>
                                                    <div className="smoothing-tooltip">
                                                        <h4>ÁßªÂãïÂπ≥Âùá (Moving Average):</h4>
                                                        <ul>
                                                            <li>„Ç¶„Ç£„É≥„Éâ„Ç¶„Çµ„Ç§„Ç∫: 3, 5, 10, 20</li>
                                                            <li>ÂêÑ„Éá„Éº„Çø„Éù„Ç§„É≥„Éà„Çí‰∏≠ÂøÉ„Å®„Åó„ÅüÁ™ì„ÅÆÂπ≥ÂùáÂÄ§„ÇíË®àÁÆó</li>
                                                            <li>Âºè: <code>smoothed[i] = Œ£(data[j]) / count</code></li>
                                                            <li style={{ marginLeft: '20px' }}><code>j ‚àà [i-‚åäw/2‚åã, i+‚åàw/2‚åâ]</code></li>
                                                            <li>„Ç®„ÉÉ„Ç∏ÈÉ®ÂàÜ„ÅØÂà©Áî®ÂèØËÉΩ„Å™„Éá„Éº„Çø„ÅÆ„Åø„ÅßË®àÁÆó</li>
                                                        </ul>
                                                        <h4 style={{ marginTop: '8px' }}>ÊåáÊï∞ÁßªÂãïÂπ≥Âùá (Exponential Moving Average):</h4>
                                                        <ul>
                                                            <li>Œ±ÂÄ§: 0.1, 0.3, 0.5</li>
                                                            <li>Âºè: <code>smoothed[i] = Œ± √ó data[i] + (1 - Œ±) √ó smoothed[i-1]</code></li>
                                                            <li>Œ±ÂÄ§„ÅåÂ∞è„Åï„ÅÑ„Åª„Å©Êªë„Çâ„Åã„Å´„Å™„ÇãÔºàÈÅéÂéª„ÅÆÂΩ±Èüø„ÅåÂº∑„ÅÑÔºâ</li>
                                                        </ul>
                                                    </div>
                                                </div>
                                                <span className="text-xs text-gray-600">
                                                    {zoomRange.min} - {zoomRange.max !== null ? zoomRange.max : records.length - 1}
                                                </span>
                                            </div>
                                            <div className="chart-container" style={{ height: 'calc(100% - 100px)' }}>
                                                <canvas ref={chartRef}></canvas>
                                            </div>
                                            </div>
                                        </ResizablePanel>

                                        {/* Statistics and Current Record Data - Full Height */}
                                        <div className="flex gap-2" style={{ flex: 1, minHeight: 0 }}>
                                            {/* Statistics Panel - 70% width */}
                                            <div className="bg-panel rounded-lg shadow p-3 overflow-hidden flex flex-col" style={{ flex: '7', minHeight: 0 }}>
                                                <h3 className="text-sm font-semibold mb-2">Statistics</h3>
                                                <div className="flex gap-3" style={{ flex: 1, minHeight: 0 }}>
                                                    {/* Histogram on the left */}
                                                    <div className="flex flex-col" style={{ width: '300px', flexShrink: 0 }}>
                                                        <div style={{ flex: 1, minHeight: 0, position: 'relative' }}>
                                                            <canvas id="histogram"></canvas>
                                                        </div>
                                                    </div>

                                                    {/* Statistics table on the right */}
                                                    <div className="overflow-y-auto" style={{ flex: 1, minHeight: 0 }}>
                                                    <table className="w-full text-xs">
                                                        <thead>
                                                            <tr style={{ backgroundColor: 'var(--bg-hover)' }}>
                                                                <th className="py-1 px-2 text-left">Key</th>
                                                                <th className="py-1 px-1 text-center">Mean</th>
                                                                <th className="py-1 px-1 text-center">Std</th>
                                                                <th className="py-1 px-1 text-center">Min</th>
                                                                <th className="py-1 px-1 text-center">Max</th>
                                                                <th className="py-1 px-1 text-center">Median</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            {Object.entries(statistics).map(([key, stats]) => (
                                                                <tr key={key} className="border-b hover:bg-panel-hover">
                                                                    <td className="py-1 px-2 font-medium text-xs">{key}</td>
                                                                    <td className="py-1 px-1 text-center text-xs">
                                                                        {stats.mean?.toFixed(3) || 'N/A'}
                                                                    </td>
                                                                    <td className="py-1 px-1 text-center text-xs">
                                                                        {stats.std?.toFixed(3) || 'N/A'}
                                                                    </td>
                                                                    <td className="py-1 px-1 text-center text-xs">
                                                                        {stats.min?.toFixed(3) || 'N/A'}
                                                                    </td>
                                                                    <td className="py-1 px-1 text-center text-xs">
                                                                        {stats.max?.toFixed(3) || 'N/A'}
                                                                    </td>
                                                                    <td className="py-1 px-1 text-center text-xs">
                                                                        {stats.median?.toFixed(3) || 'N/A'}
                                                                    </td>
                                                                </tr>
                                                            ))}
                                                        </tbody>
                                                    </table>
                                                    </div>
                                                </div>
                                            </div>

                                            {/* Current Record Data - 30% width */}
                                            <div className="bg-panel rounded-lg shadow p-3 overflow-hidden flex flex-col" style={{ flex: '3', minHeight: 0 }}>
                                                <h3 className="text-sm font-semibold mb-2">Current Record Data</h3>
                                                <div className="overflow-y-auto" style={{ flex: 1, minHeight: 0 }}>
                                                    <table className="w-full text-xs">
                                                        <tbody>
                                                            {Object.entries(currentRecord)
                                                                .filter(([key]) => !key.endsWith('/image_array') &&
                                                                    !['_absolute_index', '_display_index', '_index', '_is_deleted'].includes(key))
                                                                .map(([key, value]) => (
                                                                    <tr key={key} className="border-b">
                                                                        <td className="py-1 font-medium">{key}</td>
                                                                        <td className="py-1 text-right">
                                                                            {typeof value === 'object' ? 
                                                                                JSON.stringify(value) : 
                                                                                String(value)}
                                                                        </td>
                                                                    </tr>
                                                                ))}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* File Browser Modal */}
                        {showFileBrowser && (
                            <FileBrowser
                                onSelectFolder={(folderPath) => {
                                    setShowFileBrowser(false);
                                    loadData(folderPath);
                                }}
                                onClose={() => setShowFileBrowser(false)}
                            />
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<DonkeycarViewer />);
        {% endraw %}
    </script>
</body>
</html>